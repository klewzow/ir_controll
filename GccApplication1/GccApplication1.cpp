 #include "mine.h"
ISR(INT0_vect)
{
	 read_start_bit();
}
ISR(INT1_vect)
{
	resive_433();
}
ISR(TIMER1_COMPA_vect)
{
 
	 
       resset_flags();
	   TCCR1B &=~(1<<CS11);
	   TCCR1B &=~ (1<<CS10); 
	   GICR  |=   (1<<INT1)| (1<<INT0); 
	  
}
ISR(TIMER2_OVF_vect)
{
 resset_flags_433();
}
int main(void)
{	 
	DDRB |=(1<<6)|(1<<7);  // ƒл€  варца
	//++++++++++++++++++++++++++INT 0++++++++++++++++++++++++++++++++++//
	 
	 
	DDRD &=~  (1<<2);		// ¬ход INT0
	PORTD  |= (1<<2);       // ¬ход INT0 высокий
    MCUCR |= (1<<ISC00);    // прерывани€ по любому INT0
	GICR  |= (1<<INT0);     // вектор прерывани€ разрешить
	//++++++++++++++++++++++++++INT 0++++++++++++++++++++++++++++++++++//
	//++++++++++++++++++++++++++INT 1++++++++++++++++++++++++++++++++++//
	DDRD  &=~ (1<<3); // int1 на вход значение на порту 0
	PORTD &=~ (1<<3);
	// прерывани€ int1 по возростанию
	MCUCR |= (1<<ISC11);
	MCUCR |= (1<<ISC10);
	GICR  |= (1<<INT1);
	//++++++++++++++++++++++++++INT 1++++++++++++++++++++++++++++++++++//
	DDRD  &=~(1<<4);					// —брос EEMEM
	PORTD |= (1<<4);					// —брос EEMEM
	DDRC    |=  (1<<2)|(1<<1)|(1<<0);  //симисторы
	PORTC   |= (1<<2)|(1<<1)|(1<<0);   //симисторы
	DDRD    |=  (1<<7)|(1<<6)|(1<<5);  //индикаци€
	DDRB    |=  (1<<0);				   //индикаци€
	TCCR1B |= (1<<WGM12);
	TIMSK |= (1<<OCIE1A);
    OCR1A = 40000;
    TCCR1B |= (1<<CS11);
	init_timer2_433();
    read_EEPROM_memory();
	
	asm("sei");  
    while(1)
    {
	 if ((PIND & (1<<4))==0)
		{
			 resset_memory();
		}
	}
} 